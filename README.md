# TaskManagementService

## Описание проекта

Сервис для управления задачами с возможностью синхронного и асинхронного взаимодействия между компонентами системы. Проект создан в рамках выполнения технического задания.

## Задания

### Задание 1: API-сервис управления задачами

**Цель задания:**
Создание API-сервиса, предназначенного для простого управления задачами пользователя (Task Management Service).

**Функциональные требования:**
1. Создание, удаление и получение задач пользователя:
   - Каждая задача содержит:
     - Название задачи (Title)
     - Описание задачи (Description)
     - Статус задачи (новая, в работе, выполненная) (Status)
     - Дату создания и дату изменения (CreatedAt, UpdatedAt)
2. Синхронное взаимодействие между сервисами:
   - Реализован отдельный сервис-слушатель, который предоставляет методы получения данных о событиях изменения задачи и логирует их.
3. Асинхронное взаимодействие между сервисами через RabbitMQ:
   - При создании, изменении или удалении задачи отправляются события (producer)
   - Создан отдельный сервис-слушатель очереди (consumer), который принимает события об изменении задачи и логирует их

**Технический стек:**
- .NET 8 / ASP.NET Core
- Entity Framework Core для работы с БД
- PostgreSQL
- RabbitMQ
- Логирование и трассировка (OpenTelemetry)

**Дополнительные реализованные требования:**
- Dockerfile и возможность запуска через Docker Compose
- Структура проекта согласно принципам SOLID и чистой архитектуры

### Задание 2: SQL табличная функция

**Цель задания:**
Создание табличной функции SQL, которая возвращает по ClientId и интервалу дат (тип Date) поденные суммы платежей. Если за указанный день не было платежей, функция возвращает 0. Интервалы дат могут охватывать несколько лет.

**Структура данных:**
Таблица платежей клиентов ClientPayments со следующим схемой:
- Id bigint (первичный ключ таблицы)
- ClientId bigint (Id клиента)
- Dt datetime2(0) (дата платежа)
- Amount money (сумма платежа)

## Основные компоненты системы

### API (TaskManagementService.API)
- REST API с контроллерами для работы с задачами
- Swagger документация
- Обработка ошибок и валидация запросов
- Конфигурация приложения и middleware

### Domain (TaskManagementService.Domain)
- Содержит основные сущности

### Application (TaskManagementService.Application)
- Бизнес-логика
- DTOs
- Сервисы
- Маппинг
- Валидаторы
- Классы расширения 

### Infrastructure (TaskManagementService.Infrastructure)
- Реализация работы с базой данных (PostgreSQL через Entity Framework Core)
- Реализация отправки сообщений в RabbitMQ
- Миграции и инициализация БД

### Listener (TaskManagementService.Listener)
- Синхронный приемник событий через HTTP API
- Логирование полученных событий

### EventConsumer (TaskManagementService.EventConsumer)
- Асинхронный приемник событий из RabbitMQ
- Логирование полученных событий

## Архитектурные особенности

Проект следует принципам чистой архитектуры с четким разделением ответственности:

- **API-слой**: только контроллеры, валидация входных данных и возврат результатов
- **Application-слой**: вся бизнес-логика, DTO, маппинги и сервисы
- **Domain**: изолированная доменная модель

Преимущества такого подхода:
- Бизнес-логика не зависит от способа доставки и может использоваться разными клиентами
- При создании нового интерфейса достаточно подключить Application-слой
- Контроллеры становятся "тонкими", а Program.cs фокусируется только на конфигурации
- Возможность замены API-фреймворка без изменения бизнес-логики

## Инструкция по запуску

### Предварительные требования
- Убедитесь, что Docker Desktop настроен на использование WSL2.

### Шаги по запуску
1. Клонируйте репозиторий:
```
git clone <URL_репозитория>
cd <папка_проекта>
```

2. Запустите приложение с помощью Docker Compose:
```
docker-compose up --build
```

3. API будет доступен по адресу: http://localhost:5000/

4. Уведомления, логирование и трассировка доступны в логах контейнера.

## SQL функция для получения поденных платежей

```sql
CREATE FUNCTION dbo.GetDailyPayments
(
    @ClientId BIGINT,
    @StartDate DATE,
    @EndDate DATE
)
RETURNS TABLE
AS
RETURN
(
    WITH DateRange AS (
        SELECT 
            DATEADD(DAY, Numbers.n, @StartDate) AS PaymentDate
        FROM (
            SELECT TOP (
                CASE 
                    WHEN @StartDate > @EndDate THEN 0 
                    ELSE DATEDIFF(DAY, @StartDate, @EndDate) + 1 
                END
            )
                ROW_NUMBER() OVER (ORDER BY (SELECT NULL)) - 1 AS n
            FROM 
                master.dbo.spt_values
            WHERE 
                type = 'P'
        ) AS Numbers
        WHERE 
            @StartDate <= @EndDate
    )
    SELECT 
        DR.PaymentDate,
        ISNULL(SUM(CP.Amount), 0) AS TotalAmount
    FROM 
        DateRange DR
        LEFT JOIN ClientPayments CP 
            ON DR.PaymentDate = CAST(CP.Dt AS DATE) 
            AND CP.ClientId = @ClientId
    GROUP BY 
        DR.PaymentDate
);
```

Эта функция генерирует диапазон дат в заданном интервале и для каждой даты возвращает сумму платежей клиента. Если в определенный день платежей не было, возвращается 0.

